# コマンドライン・インターフェイス・ガイドライン

よりよいコマンドライン・プログラムを書くための [オープンソース](https://github.com/cli-guidelines/cli-guidelines) のガイド。伝統的なUNIXの原則を元に、現代版にアップデートしています。  

## 著者 {#authors}

**Aanand Prasad** \
Engineer at Squarespace, co-creator of Docker Compose. \
[@aanandprasad](https://twitter.com/aanandprasad)

**Ben Firshman** \
Co-creator [Replicate](https://replicate.ai/), co-creator of Docker Compose. \
[@bfirsh](https://twitter.com/bfirsh)

**Carl Tashian** \
Developer Advocate at [Smallstep](https://smallstep.com/), first engineer at Zipcar, co-founder Trove. \
[tashian.com](https://tashian.com/) [@tashian](https://twitter.com/tashian)

**Eva Parish** \
Technical Writer at Squarespace, O’Reilly contributor.\
[evaparish.com](https://evaparish.com/) [@evpari](https://twitter.com/evpari)

Design by [Mark Hurrell](https://mhurrell.co.uk/). Thanks to Andreas Jansson for early contributions, and Andrew Reitz, Ashley Williams, Brendan Falk, Chester Ramey, Dj Walker-Morgan, Jacob Maine, James Coglan, Michael Dwan, and Steve Klabnik for reviewing drafts.

<iframe class="github-button" src="https://ghbtns.com/github-btn.html?user=cli-guidelines&repo=cli-guidelines&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>

[Join us on Discord](https://discord.gg/EbAW5rUCkE) if you want to discuss the guide or CLI design.


## はじめに {#foreword}

1980年代には、パーソナル・コンピュータに何かやらせようと思ったら、`C:\>` とか `~$` を前にして、何をタイプすればいいか知っている必要があった。
ヘルプといえるのは、リング綴じの分厚いマニュアルだけ。
エラーメッセージも不明快。
頼りになる Stack Overflow もまだなかった。
だが、運よくインターネットにつなぐことさえできれば、Usenet（初期のインターネット・コミュニティで、同じような不満を抱える人で満ち溢れていた）の力を借りることはできた。
問題解決を助けてくれることもあったし、少なくとも、精神的にサポートしたり、仲間意識を持たせてはくれた。

40年経って、コンピュータは誰にとっても、ずっと近づきやすいものになった。その背後でよく割愛されるのがローレベルのユーザーコントロールだ。
多くのデバイスでは、そもそもコマンドラインでアクセスする手段がない。壁で仕切った箱庭とアプリストアによってもたらされる企業の利益に反するから、というのもその一因だろう。

今ではほとんどの人がコマンドラインの何たるかを知らない。わざわざそれを使いたいと思う理由など、なおのことない。
コンピュータ界のパイオニア Alan Kay は、[2017 年のインタビュー](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now) でこう言っている。「コンピューティングとは何か、ということがわかっていないから、iPhone にそれが入っていると思ったりするわけだけど、こうした勘違いは『Guitar Hero』とホンモノのギターを同じだと考えるくらい、たちの悪い勘違いだ」

Kay にとっての「ホンモノのギター」とは、厳密に言うと CLI ではない。
彼が言うのは CLI のパワーを備えつつ、ソフトウェアをテキストファイルで書くというやり方を超えたコンピュータ・プログラミングのあり方だ。
Kay の一派の間では、何十年も続いてきたテキストをベースにした局所的な最適化から開放されるべきだ、という信念がある。

将来、どれほど変わったやり方でコンピュータをプログラムするようになるのか、想像するのは楽しい。
今もうすでに、スプレッドシートはぶっちぎりで人気のあるプログラム言語だし、ノーコードの動きも急速に盛り上がっている。才能あるプログラマに集中する需要の一部をこれで代替できるのでは、と見込まれているからだ。

だが、何十年来の制約であちこち軋みがあり、いわく言い難いクセを持ちながらも、コマンドラインは今なお、コンピュータのもっとも _多才な_ 側面をなしている。
幕を開け、実際何が起こっているのかを見きわめ、マシンと創造的にやりとりする。こうしたことが、GUIには不可能な精巧さ、深さでできるのだ。
ほとんどどんなラップトップにも入っていて、学ぶ気持ちさえあれば、誰にでも利用できる。
対話的に使うことも、自動化することもできる。
さらに、システムの中では、他の部分よりも陳腐化しにくい。
安定性の中に創造的な価値があるのだ。

というわけで、まだ手元にあるうちは、その利便性とアクセシビリティを最大限に引き出すべきだろう。

コンピュータのプログラム方法も、黎明期のころとはずいぶん変わった。
かつてのコマンドラインは _マシン・ファースト_ 、スクリプト環境の上に構築されたREPLに毛の生えたようなものでしかなかった。
だが、汎用のインタープリター言語が繁栄するにつれて、シェルスクリプトの役割は小さくなっていった。
現代のコマンドラインは  _ヒューマン・ファースト_ 、あらゆる種類のツール、システム、プラットフォームにアクセスできるテキストベースのUIである。
かつては、エディタはターミナルの中で起動した。今では、ターミナルは、エディタの中の一機能になっていることも多い。
また、`git` 的な、マルチツール型のコマンドが増えている。
コマンドの中のコマンド、個々の機能だけでなく、ワークフロー全体をカバーできるハイレベルのコマンドである。

伝統的なUNIXの哲学に触発され、CLI環境をより楽しく、アクセシブルなものにしようという意図のもと、プログラマとしての自分たちの経験を元に、コマンドライン・プログラムのベストプラクティスと設計原則を改めてまとめておくことにした。

コマンドラインよ、永遠なれ！

## 序論 {#introduction}

この文書では、ハイレベルの設計原則と具体的なガイドラインの両方をカバーする。
ガイドラインの方が厚みがあるが、それは「原理原則にこだわりすぎるな」という実践家としての原理原則に起因している。
実例がある方がわかりやすいと信じているので、たくさんの実例を掲載した。

このガイドでは、emacs や vim のような、フルスクリーンの端末プログラムは扱わない。
フルスクリーン・プログラムはニッチなプロジェクトで、その種のものを設計する立場になることはめったにないからだ。

また、このガイドでは、基本的にプログラム言語やツールについてはこだわらない。

このガイドはどういう人に向いているか？
- CLI プログラムを作っていて、UIデザインに関する原則や具体的なベストプラクティスを求めている人。このガイドはあなた向きである。
- プロの「CLI UI デザイナー」。すごいですね。ぜひお説をお伺いしたいものです。
- 40 年にわたるCLIデザインのお作法として当たり前とされてきたようなことを踏み外さないようにしたい人。このガイドはあなた向きである。
- 優れたデザインと役に立つヘルプを備えたプログラムでみんなを喜ばせたい人。このガイドはまさにあなた向きである。
- GUI プログラムを作る人。このガイドはあなた向きでない。ただ、それでも目を通してもらえるなら、GUI のアンチパターンを学べるかもしれない。
- 没入型のフルスクリーン CLI に Minecraft を移植したい人。このガイドはあなた向きでない。
（でも、ぜひ見てみたい！）

## 原理原則 {#philosophy}

私たちの考える優れたCLIデザインの基本原則は以下の通り。

## ヒューマン・ファーストのデザイン {#human-first-design}

伝統的に、UNIX のコマンド群は、主として他のプログラムから使われることを前提に書かれている。
グラフィカルなアプリケーションというよりは、プログラム言語の関数に近いものだ。

今では、多くの CLI プログラムは主として（あるいは例外なく）人間が使っているにも関わらず、そのインタラクション・デザインは過去の遺物を引きずっている。
そろそろ、こうした遺物を切り捨てる時だ。そのコマンドが使うのが主として人間であるのなら、ヒューマン・ファーストのデザインにすべきだ。

### 連携して動作するシンプルな部品 {#simple-parts-that-work-together}

[もともとの UNIX 原則](https://en.wikipedia.org/wiki/Unix_philosophy) が掲げる根本信条は、小さく、シンプルなプログラムに、クリーンなインターフェイスを持たせ、それらの組み合わせで大きなシステムを構築しようという発想だ。
ひとつのプログラムにどんどん機能を詰め込むのではなく、組み合わせ可能なようにモジュール化したプログラムを作るわけである。

昔は、プログラムを作成する上で、パイプやシェルスクリプトが果たす役割は非常に大きかった。
汎用のインタープリター言語の登場で、その役割は縮小したかもしれないが、完全に消滅したわけではないのは確かだ。
さらにいうと、大規模オートメーション、CI/CDという形でのオーケストレーションと構成管理は隆盛をみている。
プログラムを組み込みできるようにしておくことは、今もなお重要だ。

幸運にも、長年にわたって確立された UNIX 環境のお作法は、まさにこうした目的のために設計されていて、今もなお役に立つ。
標準入力／出力／エラー、シグナル、終了コード等々といった仕組みで、異なるプログラムをうまく連動させることができる。
行志向のプレーンテキストは、パイプによるコマンド間の受け渡しが容易だ。
JSONはずっと最近の発明だが、必要に応じてより高度な構造を可能にしてくれる。コマンドライン・ツールとウェブの連携も簡単になる。

どんなツールを書いているにせよ、それが予想もしない使われ方をすることは確実だ。
あなたのツールが、より大きなシステムの一部になるのは _間違いない_。その時に与えられる選択肢は、扱いやすいパーツになるかどうかだけ。

一番大事なのは、組み込みを意識したデザインと、ヒューマン・ファーストのデザインは、必ずしも相容れないものではない、ということだ。
この文書に掲載したアドバイスの多くは、これを実現する方法に関するものだ。

### プログラム間の一貫性 {#consistency-across-programs}

ターミナルのお作法は私たちの指に染み込んでいる。
コマンドラインのシンタックス、フラグ、環境変数などを学習するという前払いを要求されるが、長期的な効率という面では見合うものだ…プログラム間に一貫性があれば、の話だが。

可能な限り、CLI は既存のパターンに従うべきだ。
そうすれば、CLIは直感的で予測可能になり、ひいてはユーザの効率につながる。

とはいうものの、ときには一貫性と使いやすさが両立しないこともある。
たとえば、長らく定番となっている UNIX コマンド群は、デフォルトではわずかな情報しかアウトプットしない。コマンドラインに馴染みのない人にとっては、混乱と不安のもとになりかねない。

以下のお作法がプログラムのユーザビリティを下げている場合、離脱すべきときかもしれない—だたし、この種の決断は慎重に。

### 最低限十分なメッセージ {#saying-just-enough}

ターミナルは純粋な情報の世界だ。
情報こそインターフェイスだ、という主張もありうる—そしてまた、どんなインターフェイスでもそうだが、うるさすぎる場合と、静かすぎる場合がある。

何分も止まったままで、壊れてるんじゃないかとユーザが心配しだすようなら、そのコマンドは静かすぎる。
デバッグ用のアウトプットが延々と吐き出され、本当に重要なものがゴミの中に埋もれてしまうようなら、そのコマンドはうるさすぎる。
いずれも結果は同じ：明快さに欠け、ユーザを混乱させ、イライラさせてしまう。

このバランスをとるのが実に難しい場合がある。だが、ユーザに力を授け、助けになるソフトウェアにするためには、絶対に欠かせないことだ。

### 発見のしやすさ {#ease-of-discovery}

機能を見つけやすくするという点では、GUI が一枚上手だ。
できることがすべて目の前の画面上に並んでいるから、何も勉強しなくても必要なものが見つけられるし、予想外の機能だって見つかるかもしれない。

コマンドライン・インターフェイスはこの正反対だと思われている。どんなやり方もすべて覚えておかなくてはならないと。
1987年に出た最初の [Macintosh Human Interface Guidelines](https://archive.org/details/applehumaninterf00appl) では、「見て指差す（覚えてタイプするではなく）」方式を推奨している。それがあたかも二択問題であるかのように。

この両者は必ずしも排他的とは限らない。
コマンドラインの効率性はコマンドを記憶することで実現されるが、コマンドの学習や記憶を補助することだってできるはずだ。

発見のある CLI には総合的なヘルプ文があり、たくさんの実例を備えていて、エラーの際には対処法を示してくれる。
GUI には、たとえ相手がパワーユーザであっても、CLI を学びやすく、使いやすいものにするためのヒントがたくさん詰まっている。

_Citation: The Design of Everyday Things (Don Norman), Macintosh Human Interface Guidelines_

### 対話が基本 {#conversation-as-the-norm}

GUIデザインでは、特にその初期に _メタファー_ が頻繁に用いられた。デスクトップ、ファイル、フォルダ、ゴミ箱など。
これは非常に納得がいく。なぜならコンピュータはまだ居場所を求めてもがいていた時期だったからだ。
メタファーが実装しやすいという点は、GUIがCLIに大きく勝ることのひとつだ。
だが皮肉なことに、CLIはずっと意図しないメタファーを体現し続けてきた。それは対話だ。

ごくシンプルなコマンドを除けば、プログラムを起動するには一度のやり取りではすまない。
普通、それは一度で正解を出すことが難しいからだ。ユーザがコマンドをタイプする。エラーが出る。コマンドを変える。また別のエラーが出る、といった感じで、うまくいくまで続く。
失敗の連続から学習するという形態は、ユーザがプログラムと交わす対話に似ている。

だが、トライアル・アンド・エラーだけが対話式インターフェイスとは限らない。
他にもこのようなものがある：

- あるコマンドでツールを設定したあと、実際の利用にはどういうコマンドを使うのかを学習する。
- オペレーションの準備にいくつかコマンドを使い、最後に実行用のコマンドを叩く（例：`git add` を何回か叩いたあと、`git commit` する）。
- システムの探索ー例えば、`cd` や `ls` を使いまくってディレクトリ構造を把握する、とか、`git log` や `git show` でファイルの履歴を調べる。
- 複雑なオペレーションを実行する前に dry-run する。

コマンドライン・インタラクションには対話的な性質があると認めるということは、すなわち、そのデザインに必要なテクニックを取り入れるということだ。
ユーザが不適切な入力をしたら修正候補をサジェストしたり、複数ステップのプロセスを踏むときは、中間点を明確にするとか、あぶない操作をする前に、本当に大丈夫か確認するといったことだ。

あなたが意図するかどうかに関わらず、ユーザはソフトウェアと対話している。
最悪の場合、その対話は敵意あるものになって、ユーザをバカにし、怒らせることになってしまう。
最善の場合、その対話は好ましいものになり、ユーザをより早く未知の知識に導き、達成感を得てもらうことができる。

_参考資料: [The Anti-Mac User Interface (Don Gentner and Jakob Nielsen)](https://www.nngroup.com/articles/anti-mac-interface/)_

### 堅牢性 {#robustness-principle}

堅牢性は客観的かつ主観的な特性だ。
当たり前だが、ソフトウェアは堅牢でなければならない：予期外の入力があってもうまく扱えるとか、可能な限り、操作に冪等性がある、といったことだ。
だが、同時にそれは堅牢な _手応え_ も与えなくてはならない。

自分のソフトウェアが脆いとは思われなくないだろう。
打てば響く反応のよいソフトウェアと思ってもらいたいだろう。ペラペラの「ソフト・スイッチ」ではなく、巨大な機械式のマシンであるかのごとく。

主観的な堅牢性を持たせるには細部への配慮が欠かせない。また、どんな落とし穴がありうるかについて、想像力も必要だ。
細かいポイントがたくさんある：今起こっていることについてユーザにこまめに知らせる。よくあるエラーについてその意味を説明する。不気味な印象のスタックトレースは表示しない。

一般則として、堅牢性はシンプルさを保つことからももたらされる。
特殊な例外や、複雑なコードがたくさんあるプログラムは脆弱になる。

### 共感 {#empathy}

コマンドライン・ツールは、プログラマの創造的なツールキットだから、使っていて楽しいものであるべきだ。
だからといって、何もビデオゲームにしたり、絵文字をたくさん使えばいいというわけではない（もっとも、絵文字自体に罪はないのだが 😉）。
それは、ユーザの味方であると感じてもらうことであり、ユーザの成功のために、問題点について、解決方法について、よく考えてあると感じてもらうことである。

ユーザの味方だと感じてもらうための決まった行動リストがあるわけではない。だが、私たちのアドバイスにしたがうことで、いくらかでもその方向に進んでもらうことができればうれしい。
ユーザに喜んでもらうとは、随所で _彼らの期待を超える_ ことを意味する。それは共感から始まる。

### カオス {#chaos}

ターミナルの世界はとっ散らかっている。
一貫性がないのは当たり前で、私たちは足を引っ張られ、自信がゆらぐこともある。

とはいえ、このカオスがパワーの源であることも否定できない。
ターミナルは、UNIX由来のコンピュータ環境が概してそうであるように、作るものに制限を設けることはごくまれである。
このような空間で、ありとあらゆる発明が花開く。

皮肉なことに、この文書では既存のパターンに従うことを推奨しているが、何十年ものコマンドラインの伝統とは矛盾するアドバイスだ。
私たちも、ルールを破ることにかけては、他のみんなと同じスネの傷を持つ。

いつかあなたもまた、ルールを破らざるをえない時が来るだろう。
やるなら、はっきりとした意図と、明確な目的を持ってやることだ。

> 「生産性とユーザの満足度が明らかに損なわれているときは、常識を捨てるべきである。」 — Jef Raskin, [The Humane Interface](https://en.wikipedia.org/wiki/The_Humane_Interface)

## ガイドライン {#guidelines}

コマンドライン・プログラムをよくするためにできることを、以下、具体的にまとめた。

最初のセクションには、絶対に守るべきことが入っている。
ここを間違うと、プログラムは使いにくくなるか、あるいはCLIの一員として失格になる。

それ以外は、あればなお良し、という項目だ。
これらを取り入れる時間とエネルギーがあれば、平均的なプログラムよりはるかにできのよいプログラムになるだろう。

発想としては、プログラムのデザインを考え抜く気がないなら、それでもよい、というものだ。ここのルールを守っていれば、たぶん、よいプログラムができるだろう。
一方、自分で考えた結果、あるルールが自分のプログラムには当てはまらないと言い切れるなら、それもよい。
（専制的なルールを守らなかったからと言って、あなたのプログラムを断罪できる権力者はいない）

同様に—これらのルールは石に刻まれたものでもない。
ちゃんとした理由があって一般的ルールに納得できないのなら、[変更を提案](https://github.com/cli-guidelines/cli-guidelines)していただけるとありがたい。

### 基本 {#the-basics}

守るべき基本ルールがいくつかある。
ここを間違うと、プログラムは非常に使いにくくなるか、あるいはまったく壊れてしまう。

**できるなら、コマンドライン引数パース用のライブラリを使うべし。**
使用している言語の標準機能か、またはよくできたサードパーティ製。
それらは普通、引数を受け取ってフラグをパースしたり、ヘルプテキストを表示したり、中には気を利かせてスペルの候補を出してくれたりするのが普通だ。

私たちのお気に入りは以下：
* Go: [Cobra](https://github.com/spf13/cobra), [cli](https://github.com/urfave/cli)
* Node: [oclif](https://oclif.io/)
* Python: [Click](https://click.palletsprojects.com/), [Typer](https://github.com/tiangolo/typer)
* Ruby: [TTY](https://ttytoolkit.org/)

**終了コードは、成功のときゼロ、失敗のときはゼロ以外を返すべし。**
スクリプトは、終了コードをみて、プログラムが成功したかどうかを判断する。よって、これを正確に報告しなければならない。
ゼロ以外のコードは、もっとも重要な失敗モードに割り当てよう。

**出力は `stdout` に出すべし.**
コマンドからのメインの出力は `stdout` （標準出力）にすること。
機械可読なものは何であれ `stdout` へ出す。パイプはここを通してデータをやりとりをするのがデフォルトだ。

**メッセージは `stderr` に出すべし。**
ログメッセージ、エラーなどは、すべて `stdout` に出すこと。
こうすれば、コマンドをパイプでつないだとき、メッセージはユーザに表示されるが、次のコマンドには送信されない。

### ヘルプ {#help}

**オプションが指定されていないとき、 `-h` フラグ、または `--help` フラグがついているときはヘルプ・テキストを表示する。**

**デフォルトで出すヘルプ・メッセージは簡潔に。**
可能であれば、 `myapp` または `myapp subcommand` で起動したときは、デフォルトでヘルプを表示する。
よほどシンプルなプログラムで、デフォルトの機能が明白なもの（例： `ls`）や、対話的に入力を読み込むプログラム（例：`cat`）は例外だ。

簡潔なヘルプには以下の事項だけを入れておく：

- そのプログラムにどんな機能があるかの説明。
- 起動方法の実例を1、2件。
- フラグの説明、大量にある場合は除く。
- 詳しい情報は `--help` フラグで得られることの説明

`jq` はこれがうまくできている。
 `jq` とだけタイプすると、初歩的な説明と実例が表示され、フラグの完全な説明を見たい人は `jq --help` と打つように誘導される：

```
$ jq
jq - commandline JSON processor [version 1.6]

Usage:    jq [options] <jq filter> [file...]
    jq [options] --args <jq filter> [strings...]
    jq [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output.

The simplest filter is ., which copies jq's input to its output
unmodified (except for formatting, but note that IEEE754 is used
for number representation internally, with all that that implies).

For more advanced filters see the jq(1) manpage ("man jq")
and/or https://stedolan.github.io/jq

Example:

    $ echo '{"foo": 0}' | jq .
    {
        "foo": 0
    }

For a listing of options, use jq --help.
```

**`-h` and `--help` が渡されたら完全版のヘルプを表示する。**
 