# コマンドライン・インターフェイス・ガイドライン

よりよいコマンドライン・プログラムを書くための [オープンソース](https://github.com/cli-guidelines/cli-guidelines) のガイド。伝統的なUNIXの原則を元に、現代版にアップデートしています。  

## 著者 {#authors}

**Aanand Prasad** \
Engineer at Squarespace, co-creator of Docker Compose. \
[@aanandprasad](https://twitter.com/aanandprasad)

**Ben Firshman** \
Co-creator [Replicate](https://replicate.ai/), co-creator of Docker Compose. \
[@bfirsh](https://twitter.com/bfirsh)

**Carl Tashian** \
Developer Advocate at [Smallstep](https://smallstep.com/), first engineer at Zipcar, co-founder Trove. \
[tashian.com](https://tashian.com/) [@tashian](https://twitter.com/tashian)

**Eva Parish** \
Technical Writer at Squarespace, O’Reilly contributor.\
[evaparish.com](https://evaparish.com/) [@evpari](https://twitter.com/evpari)

Design by [Mark Hurrell](https://mhurrell.co.uk/). Thanks to Andreas Jansson for early contributions, and Andrew Reitz, Ashley Williams, Brendan Falk, Chester Ramey, Dj Walker-Morgan, Jacob Maine, James Coglan, Michael Dwan, and Steve Klabnik for reviewing drafts.

<iframe class="github-button" src="https://ghbtns.com/github-btn.html?user=cli-guidelines&repo=cli-guidelines&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>

[Join us on Discord](https://discord.gg/EbAW5rUCkE) if you want to discuss the guide or CLI design.


## はじめに {#foreword}

1980年代には、パーソナル・コンピュータに何かやらせようと思ったら、`C:\>` とか `~$` を前にして、何をタイプすればいいか知っている必要があった。
ヘルプといえるのは、リング綴じの分厚いマニュアルだけ。
エラーメッセージも不明快。
頼りになる Stack Overflow もまだなかった。
だが、運よくインターネットにつなぐことさえできれば、Usenet（初期のインターネット・コミュニティで、同じような不満を抱える人で満ち溢れていた）の力を借りることはできた。
問題解決を助けてくれることもあったし、少なくとも、精神的にサポートしたり、仲間意識を持たせてはくれた。

40年経って、コンピュータは誰にとっても、ずっと近づきやすいものになった。その背後でよく割愛されるのがローレベルのユーザーコントロールだ。
多くのデバイスでは、そもそもコマンドラインでアクセスする手段がない。壁で仕切った箱庭とアプリストアによってもたらされる企業の利益に反するから、というのもその一因だろう。

今ではほとんどの人がコマンドラインの何たるかを知らない。わざわざそれを使いたいと思う理由など、なおのことない。
コンピュータ界のパイオニア Alan Kay は、[2017 年のインタビュー](https://www.fastcompany.com/40435064/what-alan-kay-thinks-about-the-iphone-and-technology-now) でこう言っている。「コンピューティングとは何か、ということがわかっていないから、iPhone にそれが入っていると思ったりするわけだけど、こうした勘違いは『Guitar Hero』とホンモノのギターを同じだと考えるくらい、たちの悪い勘違いだ」

Kay にとっての「ホンモノのギター」とは、厳密に言うと CLI ではない。
彼が言うのは CLI のパワーを備えつつ、ソフトウェアをテキストファイルで書くというやり方を超えたコンピュータ・プログラミングのあり方だ。
Kay の一派の間では、何十年も続いてきたテキストをベースにした局所的な最適化から開放されるべきだ、という信念がある。

将来、どれほど変わったやり方でコンピュータをプログラムするようになるのか、想像するのは楽しい。
今もうすでに、スプレッドシートはぶっちぎりで人気のあるプログラム言語だし、ノーコードの動きも急速に盛り上がっている。才能あるプログラマに集中する需要の一部をこれで代替できるのでは、と見込まれているからだ。

だが、何十年来の制約であちこち軋みがあり、いわく言い難いクセを持ちながらも、コマンドラインは今なお、コンピュータのもっとも _多才な_ 側面をなしている。
幕を開け、実際何が起こっているのかを見きわめ、マシンと創造的にやりとりする。こうしたことが、GUIには不可能な精巧さ、深さでできるのだ。
ほとんどどんなラップトップにも入っていて、学ぶ気持ちさえあれば、誰にでも利用できる。
対話的に使うことも、自動化することもできる。
さらに、システムの中では、他の部分よりも陳腐化しにくい。
安定性の中に創造的な価値があるのだ。

というわけで、まだ手元にあるうちは、その利便性とアクセシビリティを最大限に引き出すべきだろう。

コンピュータのプログラム方法も、黎明期のころとはずいぶん変わった。
かつてのコマンドラインは _マシン・ファースト_ 、スクリプト環境の上に構築されたREPLに毛の生えたようなものでしかなかった。
だが、汎用のインタープリター言語が繁栄するにつれて、シェルスクリプトの役割は小さくなっていった。
現代のコマンドラインは  _ヒューマン・ファースト_ 、あらゆる種類のツール、システム、プラットフォームにアクセスできるテキストベースのUIである。
かつては、エディタはターミナルの中で起動した。今では、ターミナルは、エディタの中の一機能になっていることも多い。
また、`git` 的な、マルチツール型のコマンドが増えている。
コマンドの中のコマンド、個々の機能だけでなく、ワークフロー全体をカバーできるハイレベルのコマンドである。

伝統的なUNIXの哲学に触発され、CLI環境をより楽しく、アクセシブルなものにしようという意図のもと、プログラマとしての自分たちの経験を元に、コマンドライン・プログラムのベストプラクティスと設計原則を改めてまとめておくことにした。

コマンドラインよ、永遠なれ！

## 序論 {#introduction}

この文書では、ハイレベルの設計原則と具体的なガイドラインの両方をカバーする。
ガイドラインの方が厚みがあるが、それは「原理原則にこだわりすぎるな」という実践家としての原理原則に起因している。
実例がある方がわかりやすいと信じているので、たくさんの実例を掲載した。

このガイドでは、emacs や vim のような、フルスクリーンの端末プログラムは扱わない。
フルスクリーン・プログラムはニッチなプロジェクトで、その種のものを設計する立場になることはめったにないからだ。

また、このガイドでは、基本的にプログラム言語やツールについてはこだわらない。

このガイドはどういう人に向いているか？
- CLI プログラムを作っていて、UIデザインに関する原則や具体的なベストプラクティスを求めている人。このガイドはあなた向きである。
- プロの「CLI UI デザイナー」。すごいですね。ぜひお説をお伺いしたいものです。
- 40 年にわたるCLIデザインのお作法として当たり前とされてきたようなことを踏み外さないようにしたい人。このガイドはあなた向きである。
- 優れたデザインと役に立つヘルプを備えたプログラムでみんなを喜ばせたい人。このガイドはまさにあなた向きである。
- GUI プログラムを作る人。このガイドはあなた向きでない。ただ、それでも目を通してもらえるなら、GUI のアンチパターンを学べるかもしれない。
- 没入型のフルスクリーン CLI に Minecraft を移植したい人。このガイドはあなた向きでない。
（でも、ぜひ見てみたい！）

## 原理原則 {#philosophy}

私たちの考える優れたCLIデザインの基本原則は以下の通り。

## ヒューマン・ファーストのデザイン {#human-first-design}

伝統的に、UNIX のコマンド群は、主として他のプログラムから使われることを前提に書かれている。
グラフィカルなアプリケーションというよりは、プログラム言語の関数に近いものだ。

今では、多くの CLI プログラムは主として（あるいは例外なく）人間が使っているにも関わらず、そのインタラクション・デザインは過去の遺物を引きずっている。
そろそろ、こうした遺物を切り捨てる時だ。そのコマンドが使うのが主として人間であるのなら、ヒューマン・ファーストのデザインにすべきだ。

### 連携して動作するシンプルな部品 {#simple-parts-that-work-together}

[もともとの UNIX 原則](https://en.wikipedia.org/wiki/Unix_philosophy) が掲げる根本信条は、小さく、シンプルなプログラムに、クリーンなインターフェイスを持たせ、それらの組み合わせで大きなシステムを構築しようという発想だ。
ひとつのプログラムにどんどん機能を詰め込むのではなく、組み合わせ可能なようにモジュール化したプログラムを作るわけである。

昔は、プログラムを作成する上で、パイプやシェルスクリプトが果たす役割は非常に大きかった。
汎用のインタープリター言語の登場で、その役割は縮小したかもしれないが、完全に消滅したわけではないのは確かだ。
さらにいうと、大規模オートメーション、CI/CDという形でのオーケストレーションと構成管理は隆盛をみている。
プログラムを組み込みできるようにしておくことは、今もなお重要だ。

幸運にも、長年にわたって確立された UNIX 環境のお作法は、まさにこうした目的のために設計されていて、今もなお役に立つ。
標準入力／出力／エラー、シグナル、終了コード等々といった仕組みで、異なるプログラムをうまく連動させることができる。
行志向のプレーンテキストは、パイプによるコマンド間の受け渡しが容易だ。
JSONはずっと最近の発明だが、必要に応じてより高度な構造を可能にしてくれる。コマンドライン・ツールとウェブの連携も簡単になる。

どんなツールを書いているにせよ、それが予想もしない使われ方をすることは確実だ。
あなたのツールが、より大きなシステムの一部になるのは _間違いない_。その時に与えられる選択肢は、扱いやすいパーツになるかどうかだけ。

一番大事なのは、組み込みを意識したデザインと、ヒューマン・ファーストのデザインは、必ずしも相容れないものではない、ということだ。
この文書に掲載したアドバイスの多くは、これを実現する方法に関するものだ。

### プログラム間の一貫性 {#consistency-across-programs}

ターミナルのお作法は私たちの指に染み込んでいる。
コマンドラインのシンタックス、フラグ、環境変数などを学習するという前払いを要求されるが、長期的な効率という面では見合うものだ…プログラム間に一貫性があれば、の話だが。

可能な限り、CLI は既存のパターンに従うべきだ。
そうすれば、CLIは直感的で予測可能になり、ひいてはユーザの効率につながる。

とはいうものの、ときには一貫性と使いやすさが両立しないこともある。
たとえば、長らく定番となっている UNIX コマンド群は、デフォルトではわずかな情報しかアウトプットしない。コマンドラインに馴染みのない人にとっては、混乱と不安のもとになりかねない。

以下のお作法がプログラムのユーザビリティを下げている場合、離脱すべきときかもしれない—だたし、この種の決断は慎重に。

### 最低限十分なメッセージ {#saying-just-enough}

ターミナルは純粋な情報の世界だ。
情報こそインターフェイスだ、という主張もありうる—そしてまた、どんなインターフェイスでもそうだが、うるさすぎる場合と、静かすぎる場合がある。

何分も止まったままで、壊れてるんじゃないかとユーザが心配しだすようなら、そのコマンドは静かすぎる。
デバッグ用のアウトプットが延々と吐き出され、本当に重要なものがゴミの中に埋もれてしまうようなら、そのコマンドはうるさすぎる。
いずれも結果は同じ：明快さに欠け、ユーザを混乱させ、イライラさせてしまう。

このバランスをとるのが実に難しい場合がある。だが、ユーザに力を授け、助けになるソフトウェアにするためには、絶対に欠かせないことだ。

### 発見のしやすさ {#ease-of-discovery}

機能を見つけやすくするという点では、GUI が一枚上手だ。
できることがすべて目の前の画面上に並んでいるから、何も勉強しなくても必要なものが見つけられるし、予想外の機能だって見つかるかもしれない。

コマンドライン・インターフェイスはこの正反対だと思われている。どんなやり方もすべて覚えておかなくてはならないと。
1987年に出た最初の [Macintosh Human Interface Guidelines](https://archive.org/details/applehumaninterf00appl) では、「見て指差す（覚えてタイプするではなく）」方式を推奨している。それがあたかも二択問題であるかのように。

この両者は必ずしも排他的とは限らない。
コマンドラインの効率性はコマンドを記憶することで実現されるが、コマンドの学習や記憶を補助することだってできるはずだ。

発見のある CLI には総合的なヘルプ文があり、たくさんの実例を備えていて、エラーの際には対処法を示してくれる。
GUI には、たとえ相手がパワーユーザであっても、CLI を学びやすく、使いやすいものにするためのヒントがたくさん詰まっている。

_Citation: The Design of Everyday Things (Don Norman), Macintosh Human Interface Guidelines_

### 対話が基本 {#conversation-as-the-norm}

GUIデザインでは、特にその初期に _メタファー_ が頻繁に用いられた。デスクトップ、ファイル、フォルダ、ゴミ箱など。
これは非常に納得がいく。なぜならコンピュータはまだ居場所を求めてもがいていた時期だったからだ。
メタファーが実装しやすいという点は、GUIがCLIに大きく勝ることのひとつだ。
だが皮肉なことに、CLIはずっと意図しないメタファーを体現し続けてきた。それは対話だ。

ごくシンプルなコマンドを除けば、プログラムを起動するには一度のやり取りではすまない。
普通、それは一度で正解を出すことが難しいからだ。ユーザがコマンドをタイプする。エラーが出る。コマンドを変える。また別のエラーが出る、といった感じで、うまくいくまで続く。
失敗の連続から学習するという形態は、ユーザがプログラムと交わす対話に似ている。

だが、トライアル・アンド・エラーだけが対話式インターフェイスとは限らない。
他にもこのようなものがある：

- あるコマンドでツールを設定したあと、実際の利用にはどういうコマンドを使うのかを学習する。
- オペレーションの準備にいくつかコマンドを使い、最後に実行用のコマンドを叩く（例：`git add` を何回か叩いたあと、`git commit` する）。
- システムの探索ー例えば、`cd` や `ls` を使いまくってディレクトリ構造を把握する、とか、`git log` や `git show` でファイルの履歴を調べる。
- 複雑なオペレーションを実行する前に dry-run する。

コマンドライン・インタラクションには対話的な性質があると認めるということは、すなわち、そのデザインに必要なテクニックを取り入れるということだ。
ユーザが不適切な入力をしたら修正候補をサジェストしたり、複数ステップのプロセスを踏むときは、中間点を明確にするとか、あぶない操作をする前に、本当に大丈夫か確認するといったことだ。

あなたが意図するかどうかに関わらず、ユーザはソフトウェアと対話している。
最悪の場合、その対話は敵意あるものになって、ユーザをバカにし、怒らせることになってしまう。
最善の場合、その対話は好ましいものになり、ユーザをより早く未知の知識に導き、達成感を得てもらうことができる。

_参考資料: [The Anti-Mac User Interface (Don Gentner and Jakob Nielsen)](https://www.nngroup.com/articles/anti-mac-interface/)_

### 堅牢性 {#robustness-principle}

堅牢性は客観的かつ主観的な特性だ。
当たり前だが、ソフトウェアは堅牢でなければならない：予期外の入力があってもうまく扱えるとか、可能な限り、操作に冪等性がある、といったことだ。
だが、同時にそれは堅牢な _手応え_ も与えなくてはならない。

自分のソフトウェアが脆いとは思われなくないだろう。
打てば響く反応のよいソフトウェアと思ってもらいたいだろう。ペラペラの「ソフト・スイッチ」ではなく、巨大な機械式のマシンであるかのごとく。

主観的な堅牢性を持たせるには細部への配慮が欠かせない。また、どんな落とし穴がありうるかについて、想像力も必要だ。
細かいポイントがたくさんある：今起こっていることについてユーザにこまめに知らせる。よくあるエラーについてその意味を説明する。不気味な印象のスタックトレースは表示しない。

一般則として、堅牢性はシンプルさを保つことからももたらされる。
特殊な例外や、複雑なコードがたくさんあるプログラムは脆弱になる。

### 共感 {#empathy}

コマンドライン・ツールは、プログラマの創造的なツールキットだから、使っていて楽しいものであるべきだ。
だからといって、何もビデオゲームにしたり、絵文字をたくさん使えばいいというわけではない（もっとも、絵文字自体に罪はないのだが 😉）。
それは、ユーザの味方であると感じてもらうことであり、ユーザの成功のために、問題点について、解決方法について、よく考えてあると感じてもらうことである。

ユーザの味方だと感じてもらうための決まった行動リストがあるわけではない。だが、私たちのアドバイスにしたがうことで、いくらかでもその方向に進んでもらうことができればうれしい。
ユーザに喜んでもらうとは、随所で _彼らの期待を超える_ ことを意味する。それは共感から始まる。

### カオス {#chaos}

ターミナルの世界はとっ散らかっている。
一貫性がないのは当たり前で、私たちは足を引っ張られ、自信がゆらぐこともある。

とはいえ、このカオスがパワーの源であることも否定できない。
ターミナルは、UNIX由来のコンピュータ環境が概してそうであるように、作るものに制限を設けることはごくまれである。
このような空間で、ありとあらゆる発明が花開く。

皮肉なことに、この文書では既存のパターンに従うことを推奨しているが、何十年ものコマンドラインの伝統とは矛盾するアドバイスだ。
私たちも、ルールを破ることにかけては、他のみんなと同じスネの傷を持つ。

いつかあなたもまた、ルールを破らざるをえない時が来るだろう。
やるなら、はっきりとした意図と、明確な目的を持ってやることだ。

> 「生産性とユーザの満足度が明らかに損なわれているときは、常識を捨てるべきである。」 — Jef Raskin, [The Humane Interface](https://en.wikipedia.org/wiki/The_Humane_Interface)

## ガイドライン {#guidelines}

コマンドライン・プログラムをよくするためにできることを、以下、具体的にまとめた。

最初のセクションには、絶対に守るべきことが入っている。
ここを間違うと、プログラムは使いにくくなるか、あるいはCLIの一員として失格になる。

それ以外は、あればなお良し、という項目だ。
これらを取り入れる時間とエネルギーがあれば、平均的なプログラムよりはるかにできのよいプログラムになるだろう。

発想としては、プログラムのデザインを考え抜く気がないなら、それでもよい、というものだ。ここのルールを守っていれば、たぶん、よいプログラムができるだろう。
一方、自分で考えた結果、あるルールが自分のプログラムには当てはまらないと言い切れるなら、それもよい。
（専制的なルールを守らなかったからと言って、あなたのプログラムを断罪できる権力者はいない）

同様に—これらのルールは石に刻まれたものでもない。
ちゃんとした理由があって一般的ルールに納得できないのなら、[変更を提案](https://github.com/cli-guidelines/cli-guidelines)していただけるとありがたい。

### 基本 {#the-basics}

守るべき基本ルールがいくつかある。
ここを間違うと、プログラムは非常に使いにくくなるか、あるいはまったく壊れてしまう。

**できるなら、コマンドライン引数パース用のライブラリを使うべし。**
使用している言語の標準機能か、またはよくできたサードパーティ製。
それらは普通、引数を受け取ってフラグをパースしたり、ヘルプテキストを表示したり、中には気を利かせてスペルの候補を出してくれたりするのが普通だ。

私たちのお気に入りは以下：
* Go: [Cobra](https://github.com/spf13/cobra), [cli](https://github.com/urfave/cli)
* Node: [oclif](https://oclif.io/)
* Python: [Click](https://click.palletsprojects.com/), [Typer](https://github.com/tiangolo/typer)
* Ruby: [TTY](https://ttytoolkit.org/)

**終了コードは、成功のときゼロ、失敗のときはゼロ以外を返すべし。**
スクリプトは、終了コードをみて、プログラムが成功したかどうかを判断する。よって、これを正確に報告しなければならない。
ゼロ以外のコードは、もっとも重要な失敗モードに割り当てよう。

**出力は `stdout` に出すべし.**
コマンドからのメインの出力は `stdout` （標準出力）にすること。
機械可読なものは何であれ `stdout` へ出す。パイプはここを通してデータをやりとりをするのがデフォルトだ。

**メッセージは `stderr` に出すべし。**
ログメッセージ、エラーなどは、すべて `stdout` に出すこと。
こうすれば、コマンドをパイプでつないだとき、メッセージはユーザに表示されるが、次のコマンドには送信されない。

### ヘルプ {#help}

**オプションが指定されていないとき、 `-h` フラグ、または `--help` フラグがついているときはヘルプ・テキストを表示する。**

**デフォルトで出すヘルプ・メッセージは簡潔に。**
可能であれば、 `myapp` または `myapp subcommand` で起動したときは、デフォルトでヘルプを表示する。
よほどシンプルなプログラムで、デフォルトの機能が明白なもの（例： `ls`）や、対話的に入力を読み込むプログラム（例：`cat`）は例外だ。

簡潔なヘルプには以下の事項だけを入れておく：

- そのプログラムにどんな機能があるかの説明。
- 起動方法の実例を1、2件。
- フラグの説明、大量にある場合は除く。
- 詳しい情報は `--help` フラグで得られることの説明

`jq` はこれがうまくできている。
 `jq` とだけタイプすると、初歩的な説明と実例が表示され、フラグの完全な説明を見たい人は `jq --help` と打つように誘導される：

```
$ jq
jq - commandline JSON processor [version 1.6]

Usage:    jq [options] <jq filter> [file...]
    jq [options] --args <jq filter> [strings...]
    jq [options] --jsonargs <jq filter> [JSON_TEXTS...]

jq is a tool for processing JSON inputs, applying the given filter to
its JSON text inputs and producing the filter's results as JSON on
standard output.

The simplest filter is ., which copies jq's input to its output
unmodified (except for formatting, but note that IEEE754 is used
for number representation internally, with all that that implies).

For more advanced filters see the jq(1) manpage ("man jq")
and/or https://stedolan.github.io/jq

Example:

    $ echo '{"foo": 0}' | jq .
    {
        "foo": 0
    }

For a listing of options, use jq --help.
```

**`-h` and `--help` が渡されたら完全版のヘルプを表示する。**
以下の場合は、いずれもヘルプを表示する。
 
```
$ myapp
$ myapp --help
$ myapp -h
```

これ以外のフラグや引数は無視。どんなものの後にでも `-h` が付いていたらヘルプを表示すること。
何が来ても `-h` は無効にならない。

 `git` 的なコマンドなら、以下でもヘルプを表示する：

```
$ myapp help
$ myapp help subcommand
$ myapp subcommand --help
$ myapp subcommand -h
```

**フィードバックとバグ報告ためのサポート窓口を作る**
ヘルプ・テキストの上部に、ウェブサイトか、GitHubへのリンクを置くのが通例。

**ヘルプ・テキストに、ウェブ版のドキュメントへのリンクを掲載する**
サブコマンドのページやページ内リンクがあるようなら、ダイレクトにそこへリンクする。
ウェブ上によりくわしいドキュメントがある、あるいは何かの挙動に関する説明がある場合は、これは特に有益だ。

**使用例から始める**
どんな種類のドキュメントよりも、ユーザは使用例を見たがるので、まずはヘルプページの最初に掲載しよう。特によく使われるのに複雑な使い方を載せるとよい。
やっていることがよりわかりやすくなり、しかも長すぎないで済むようなら、出力結果も載せるといい。

実例をいくつも載せることで話を進め、徐々に複雑な使い方へ進んでいくのもいいだろう。
<!-- TK example? -->

**使用例が大量にあるときは別の場所にまとめる**ようにして、チートシートコマンドや、ウェブページで見られるようにしておく。
詳細な上級者向けの実例があると役に立つが、ヘルプ・テキストが長過ぎるのも考えものだ。

より複雑なユースケース、たとえば他のツールとの連携といった話題には、別途、それ向けのチュートリアルを用意することも考慮したい。

**man ページは割愛する。**
このガイドラインに準拠してヘルプとドキュメントを作成するなら、man ページは必要ないと確信する。
man ページの利用者は限られているし、Windows では動かない。
使っている CLI フレームワークやパッケージ・マネジャーに man ページ出力機能があるなら、それを利用すればいいだろう。そうでないなら、ウェブ文書や組み込みのヘルプ・テキストの改善に注力したほうがいい。

_Citation: [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)._

**ヘルプ・テキストが長文になる場合、ページャーにパイプすること。**
 `man` が重宝するのはこの一点だ。
後述の「出力」セクションのアドバイスを参照のこと。

**ヘルプ・テキストの冒頭には、もっとも汎用的なフラグとコマンドを掲載する。**
フラグがたくさんあるのはかまわない。だが、その中でもっともよく利用されるものを一番最初に表示しよう。
たとえば、Git コマンドでは、使い始めに用いるコマンドと、最もよく利用されるサブコマンドを最初に表示している：

```
$ git
usage: git [--version] [--help] [-C <path>] [-c <name>=<value>]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status
…
```

**ヘルプ・テキストは適切に装飾する。**
見出しを太字にしておくと流し読みがしやすい。
だが、ターミナルに依存しない方法を採用するようにしよう。さもないと、ユーザはエスケープ文字の嵐を眺めることになる。

<pre>
<code>
<strong>$ heroku apps --help</strong>
list your apps

<strong>USAGE</strong>
  $ heroku apps

<strong>OPTIONS</strong>
  -A, --all          include apps in all teams
  -p, --personal     list apps in personal account when a default team is set
  -s, --space=space  filter by space
  -t, --team=team    team to use
  --json             output in json format

<strong>EXAMPLES</strong>
  $ heroku apps
  === My Apps
  example
  example2

  === Collaborated Apps
  theirapp   other@owner.name

<strong>COMMANDS</strong>
  apps:create     creates a new app
  apps:destroy    permanently destroy an app
  apps:errors     view app errors
  apps:favorites  list favorited apps
  apps:info       show detailed app information
  apps:join       add yourself to a team app
  apps:leave      remove yourself from a team app
  apps:lock       prevent team members from joining an app
  apps:open       open the app in a web browser
  apps:rename     rename an app
  apps:stacks     show the list of available stacks
  apps:transfer   transfer applications to another user or team
  apps:unlock     unlock an app so any team member can join
</code>
</pre>

注：`heroku apps --help` をページャーにパイプすると、コマンドからはエスケープ文字が出力されなくなる。

**ユーザの誤操作から本当にやりたいことを推測できるときは、サジェストを出す。**
例えば、 `brew update jq` とタイプしてきたら `brew upgrade jq` の挙動をすべきだ。

サジェストしたコマンドを実行したいか確認するのはよいが、強制はいけない。
たとえば：

```
$ heroku pss
 ›   Warning: pss is not a heroku command.
Did you mean ps? [y/n]:
```

修正後のシンタックスをサジェストするだけでなく、それを実行してあげたい誘惑に駆られるかもしれない。そもそもユーザが初めから正しいコマンドを叩いたかのように。
そうすべきときもあるが、常にそうとも限らない。

第一に、無効な入力は必ずしも単純なタイプミスとは限らない。論理的に考えた結果のミスだったり、シェル変数の誤用だったりする場合も少なくない。
危険なことをしようとしている可能性もある。アクションの結果、状態が変わってしまうような場合は特にそうだ。

第二に、ユーザがタイプしたものを勝手に変更してしまうと、正しいシンタックスを学ぶ機会がなくなる点にも注意が必要だ。
実質的に、ユーザがタイプした書式が有効か、正しいかを判断するのはあなただ。一度サポートすると決めた以上は途中で変えてはならない。
しっかりと判断して、両方のシンタックスをドキュメントに記載しておくこと。

_Further reading: [“Do What I Mean”](http://www.catb.org/~esr/jargon/html/D/DWIM.html)_

**パイプ入力を前提としたコマンドに、 `stdin` として対話式ターミナルがつながっているときは、ただちにヘルプを表示して終了する。**
これで `cat` みたいなハングはしなくなる。
もしくは `stderr` にログ・メッセージを出力してもいいだろう。

### 出力 {#output}

**人間が読める出力が最優先。**
人間が主で、マシンは従である。
出力ストリーム（`stdout` または `stderr`）を読んでいるのが人間かどうかを見分けるための方法として、経験的にもっともシンプルかつ簡単なやり方は、_TTYかどうか_ で判断することである。
このためのユーティリティやライブラリはどんな言語にもある（例： [Python](https://stackoverflow.com/questions/858623/how-to-recognize-whether-a-script-is-running-on-a-tty), [Node](https://nodejs.org/api/process.html#process_a_note_on_process_i_o), [Go](https://github.com/mattn/go-isatty)）。

_[TTY とは何か] についての詳細 (https://unix.stackexchange.com/a/4132)._

**機械可読のアウトプットはユーザビリティを損なわないところで出す。**
テキストのストリームはUNIXの汎用的なインターフェイスとなっている。
プログラムはテキストを出力するのが普通だし、入力として期待するのもまたテキストである。
それで、複数のプログラムを連携させることができるわけだ。
これは、通常、スクリプトを書けるようにすることが目的だが、
プログラムを利用する人間にとってもユーザビリティを高める場合がある。
例えば、出力をパイプで `grep` につなげば、期待通りのことができる。

> 「あらゆるプログラムの出力は、未知のものを含む他のプログラムの入力となることを前提とせよ」
— [Doug McIlroy](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html)

**人間可読な出力にすると機械可読な出力が崩れるときは `--plain` でプレーンな表形式のテキストを表示できるようにして、 `grep` や `awk` といったツールと組み合わせられるようにする。**
場合によっては、人間可読にするために、出力情報の書式を変える必要がある。
<!-- (TK example with and without --plain) -->
例えば、行単位のテーブルを表示する場合、ひとつのセルを複数行に分割して、画面幅いっぱいにできるだけ多くの情報を詰め込もうとするような場合だ。
こうすると、1行1データという期待される挙動が変わってしまう。そこで `--plain` フラグを使って、このような整形を停止し、1行1レコードで出力できるようにしておくのである。

**`--json` を渡されたら出力をJSON形式で表示する。**
JSON なら、プレーンテキストをより構造的なものにできるので、複雑なデータ構造を出力したり、取り扱ったりするのがはるかに楽になる。
[`jq`](https://stedolan.github.io/jq/) は、コマンドラインでJSONを扱う上でよく用いられるツールだ。今では JSON を出力したり操作したりするための [ツールのエコシステム](https://ilya-sher.org/2018/04/10/list-of-json-tools-for-command-line/) がすっかり整備されている。

また、ウェブでもよく利用されるので、プログラムの入出力をJSONに対応させれば、 `curl` を使ってパイプでウェブサービスとやりとりできる。

**成功したときは出力を、ただし、簡潔に。**
伝統的に、問題ないときは、UNIX コマンドはユーザに何も出力しない。
スクリプトの中で利用される場合は納得できるが、人間が利用したときはハングしたり、壊れたように見える。
例えば、長い時間がかかるときでも `cp` は何も出力しない。

何も出力しないのがデフォルトの動作としてベストだと言える状況はめったにない。だが、だいたいにおいて少なめにして失敗する方がましである。

まったく出力が不要な場合は（たとえば、シェルスクリプトの中で利用する場合）、 `stderr` を `/dev/null` にリダイレクトする手間を省くために、 `-q` オプションを設けて、重要でない出力はすべて抑止するようにする。
